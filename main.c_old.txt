/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "ILI9341_STM32_Driver.h"
#include "ILI9341_GFX.h"
#include <stdio.h> // Required for sprintf
#include <string.h>
#include "pms7003.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c2;

SPI_HandleTypeDef hspi1;
DMA_HandleTypeDef hdma_spi1_tx;

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim4;

UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
uint8_t rxByte;              // Single byte received from UART
uint8_t rxBufferPMS[32];        // Buffer for the full 32-byte frame
uint8_t rxIndex = 0;         // Current position in the buffer
PMS_Data_t sensorData;       // Parsed data

//uint16_t LedState = 0;
char DistanceBuffer[50]; // Buffer for the text to display
char MotorBuffer[50];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM1_Init(void);
static void MX_SPI1_Init(void);
static void MX_I2C2_Init(void);
static void MX_TIM4_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
volatile uint32_t ic_val1;
volatile uint32_t ic_val2;
volatile uint8_t  is_first_captured;
volatile uint8_t  done_flag;
volatile uint32_t diff;
volatile float    distance_cm;

//L98N

static inline uint32_t tim_arr(void) {
  return __HAL_TIM_GET_AUTORELOAD(&htim1);   // expect 3599
}

/* ---- Motor A ---- */
static void MotorA_SetSpeed(uint8_t duty)
{
  if (duty > 100) duty = 100;
  uint32_t arr = tim_arr();
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, (arr + 1) * duty / 100);
}

static void MotorA_SetDir(uint8_t reverse)
{

  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, reverse ? GPIO_PIN_SET 	 : GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, reverse ? GPIO_PIN_RESET  : GPIO_PIN_SET);
}

static void MotorA_Brake(void)
{

  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1, GPIO_PIN_SET);
}

static void MotorA_Coast(void)
{

  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0 | GPIO_PIN_1, GPIO_PIN_RESET);
}

/* ---- Motor B ---- */
static void MotorB_SetSpeed(uint8_t duty)
{
  if (duty > 100) duty = 100;
  uint32_t arr = tim_arr();
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_4, (arr + 1) * duty / 100);
}

static void MotorB_SetDir(uint8_t reverse)
{

  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, reverse ? GPIO_PIN_SET   : GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, reverse ? GPIO_PIN_RESET : GPIO_PIN_SET);
}

static void MotorB_Brake(void)
{
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14 | GPIO_PIN_15, GPIO_PIN_SET);
}

static void MotorB_Coast(void)
{
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14 | GPIO_PIN_15, GPIO_PIN_RESET);
}

static inline void GoForward(uint8_t duty){
  MotorA_SetDir(1); MotorB_SetDir(1);
  MotorA_SetSpeed(duty); MotorB_SetSpeed(duty);
}

/* Dừng trôi cả hai bánh */
static inline void StopCoast(void){
  MotorA_SetSpeed(0); MotorB_SetSpeed(0);
  MotorA_Coast();     MotorB_Coast();
}

/* Rẽ trái kiểu swing: dừng bánh trái (A), chạy bánh phải (B) tiến */
static inline void TurnLeft(uint8_t duty)
{
  MotorA_SetSpeed(0);
  MotorA_Brake();      // hãm A cho đứng hẳn
  MotorB_SetDir(1);    // B tiến
  MotorB_SetSpeed(duty);
}

/* Rẽ phải kiểu swing: dừng bánh phải (B), chạy bánh trái (A) tiến */
static inline void TurnRight(uint8_t duty)
{
  MotorB_SetSpeed(0);
  MotorB_Brake();      // hãm B cho đứng hẳn
  MotorA_SetDir(1);    // A tiến
  MotorA_SetSpeed(duty);
}

/* Lùi: cả 2 bánh đảo chiều và chạy với duty */
static inline void GoBack(uint8_t duty)
{
	MotorA_SetSpeed(0);
	MotorB_SetSpeed(0);
  MotorA_Coast();
	MotorB_Coast();
  MotorA_SetDir(0);
  MotorB_SetDir(0);
  MotorA_SetSpeed(duty);
  MotorB_SetSpeed(duty);
}

// HCSR04
void HCSR04_Trigger(uint8_t channel)
{
  // channel: 1 => TRIG1, 2 => TRIG2, 3 => TRIG3
  if (channel < 1 || channel > 3) return;

  GPIO_TypeDef* port = NULL;
  uint16_t pin = 0;

  if (channel == 1) { port = TRIG1_GPIO_Port; pin = TRIG1_Pin; }
  else if (channel == 2) { port = TRIG2_GPIO_Port; pin = TRIG2_Pin; }
  else { port = TRIG3_GPIO_Port; pin = TRIG3_Pin; }

  HAL_GPIO_WritePin(port, pin, GPIO_PIN_SET);
  // ~10us pulse (ước lượng simple). Nếu có DWT_Delay_us(10) thì dùng nó.
  for (volatile int i = 0; i < 120; i++) __NOP();
  HAL_GPIO_WritePin(port, pin, GPIO_PIN_RESET);
}


void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance != TIM4) return;

  uint8_t idx = 0;
  if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) idx = 0;
  else if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2) idx = 1;
  else if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3) idx = 2;
  else return;

  uint32_t cap;

  if (idx == 0) cap = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
  else if (idx == 1) cap = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
  else cap = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_3);

  if (is_first_captured == 0) {
    ic_val1 = cap;
    is_first_captured = 1;
    // set polarity to falling for this channel
    if (idx == 0) __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
    else if (idx == 1) __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_FALLING);
    else __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_3, TIM_INPUTCHANNELPOLARITY_FALLING);
  } else {
    ic_val2 = cap;
    // compute diff (handle overflow)
    if (ic_val2 > ic_val1) diff = ic_val2 - ic_val1;
    else diff = (htim4.Init.Period - ic_val1) + ic_val2 + 1;
    distance_cm = (float)diff * 0.0343f / 2.0f;
    is_first_captured = 0;
    // restore polarity to rising and disable interrupt for this channel
    if (idx == 0) {
      __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    } else if (idx == 1) {
      __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_RISING);
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    } else {
      __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_3, TIM_INPUTCHANNELPOLARITY_RISING);
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    }
  }
}


float HCSR04_Read(uint8_t channel)
{
  if (channel < 1 || channel > 3) return -1.0f;

  // reset trạng thái trước đo
  is_first_captured = 0;
  ic_val1 = 0;
  ic_val2 = 0;
  diff = 0;
  distance_cm = 0.0f;

  // set capture polarity RISING & enable IT cho kênh
  if (channel == 1) {
    __HAL_TIM_SET_CAPTUREPOLARITY(&htim4, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
    __HAL_TIM_ENABLE_IT(&htim4, TIM_IT_CC1);
  } else if (channel == 2) {
    __HAL_TIM_SET_CAPTUREPOLARITY(&htim4, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_RISING);
    __HAL_TIM_ENABLE_IT(&htim4, TIM_IT_CC2);
  } else {
    __HAL_TIM_SET_CAPTUREPOLARITY(&htim4, TIM_CHANNEL_3, TIM_INPUTCHANNELPOLARITY_RISING);
    __HAL_TIM_ENABLE_IT(&htim4, TIM_IT_CC3);
  }

  // Trigger sau khi đã sẵn sàng capture
  HCSR04_Trigger(channel);

  // chờ callback cập nhật distance_cm, timeout ~60ms
  uint32_t start = HAL_GetTick();
  while (distance_cm == 0.0f) {
    if (HAL_GetTick() - start > 100) {
      // timeout: disable IT cho kênh tương ứng
      if (channel == 1)      __HAL_TIM_DISABLE_IT(&htim4, TIM_IT_CC1);
      else if (channel == 2) __HAL_TIM_DISABLE_IT(&htim4, TIM_IT_CC2);
      else                   __HAL_TIM_DISABLE_IT(&htim4, TIM_IT_CC3);
      return -1.0f;
    }
  }

  // callback của bạn đã tự disable IT (theo code hiện tại)
  return distance_cm;
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_TIM1_Init();
  MX_SPI1_Init();
  MX_I2C2_Init();
  MX_TIM4_Init();
  MX_USART1_UART_Init();
  MX_USART2_UART_Init();
  /* USER CODE BEGIN 2 */

  // Start the first interrupt-driven receive
  HAL_UART_Receive_IT(&huart2, &rxByte, 1);

  /* Start PWM on TIM3 CH1 (ENA) & CH2 (ENB) */
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);
  HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_1);
  HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_2);
  HAL_TIM_IC_Start_IT(&htim4, TIM_CHANNEL_3);


  HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, 1);
  HAL_GPIO_WritePin(RELAY1_GPIO_Port, RELAY1_Pin, 0);
  HAL_GPIO_WritePin(RELAY2_GPIO_Port, RELAY2_Pin, 0);
  // Start the Timer for the sensor
//  HAL_TIM_Base_Start(&htim1);
//  HAL_GPIO_WritePin(TRIG_PORT, TRIG_PIN, GPIO_PIN_RESET);

  // Initialize Display
  ILI9341_Init();
  ILI9341_FillScreen(WHITE);
  ILI9341_SetRotation(SCREEN_HORIZONTAL_2);

  // Draw static text once to save time
  ILI9341_DrawText("EDDIE: The Cleaning Robot", FONT3, 30, 10, BLUE, WHITE);


  uint8_t rxBuffer[512] = {0};
      uint8_t ATisOK;
      int channel;
//      int onoff;
      int wheelState;
      int brushState;
//      int led = 1;
      int wheel = 1;
      int brush = 1;
      char ATcommand[64];
      char ATcommandB[1024];
      char ATcommandN[100];
      char ATcommandF[100];
      char ATcommandT[16];

//      sprintf(ATcommandB,"<!DOCTYPE html><html>\n<head>\n\
//      <title>STM32 - ESP8266</title>\n<link href=\"data:image/x-icon;base64,\
//      A\" rel=\"icon\" type=\"image/x-icon\"><style>\nhtml {\
//      display: inline-block; margin: 0px auto; text-align: center;}\n\
//      body{margin-top: 50px;}\n.button {display: block;\n\
//      width: 70px;\nbackground-color: #008000;\nborder: none;\ncolor: white;\n\
//      padding: 14px 28px;\ntext-decoration: none;\nfont-size: 24px;\n\
//      margin: 0px auto 36px; \nborder-radius: 5px;}\n\
//      .button-on {background-color: #008000;}\n.button-on:active\
//      {background-color: #008000;}\n.button-off {background-color: #808080;}\n\
//      .button-off:active {background-color: #808080;}\n\
//      p {font-size: 14px;color: #808080;margin-bottom: 20px;}\n\
//      </style>\n</head>\n<body>\n<h1>STM32 - Cleaning Robot</h1>");

      sprintf(ATcommandB,
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=utf-8\r\n"
        "Connection: close\r\n"
        "\r\n"
        "<!DOCTYPE html><html><head>"
        "<style>"
        "body{background:black;color:white;font-family:Arial;}"
        ".button{padding:10px;margin:5px;display:inline-block;"
        "background:#444;color:white;text-decoration:none;}"
        "</style>"
        "</head><body>"
      );


//      sprintf(ATcommandN,"<p>Robot is cleaning ~~~\
//      </p><a class=\"button button-off\" href=\"/wheeloff\">WHEEL OFF</a>");

      sprintf(ATcommandN,
        "<p>Robot is cleaning ~~~</p>"
        "<a class=\"button\" href=\"/wheeloff\">WHEEL OFF</a>"
        "<a class=\"button\" href=\"/wheelon\">WHEEL ON</a><br/>"
        "<a class=\"button\" href=\"/brushoff\">BRUSH OFF</a>"
        "<a class=\"button\" href=\"/brushon\">BRUSH ON</a><br/>"
      );

      sprintf(ATcommandF,"<p>Robot is sleeping zzz\
      </p><a class=\"button button-on\" href=\"/wheelon\">WHEEL ON</a>");

      sprintf(ATcommandT,"</body></html>");

      int countB = strlen(ATcommandB);
      int countN = strlen(ATcommandN);
      int countF = strlen(ATcommandF);
      int countT = strlen(ATcommandT);

      sprintf(ATcommand,"AT+RST\r\n");
      memset(rxBuffer,0,sizeof(rxBuffer));
      HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
      HAL_UART_Receive (&huart1, rxBuffer, 512, 100);
      HAL_Delay(500);

      ATisOK = 0;
      while(!ATisOK){
        sprintf(ATcommand,"AT+CWMODE_CUR=2\r\n");
          memset(rxBuffer,0,sizeof(rxBuffer));
          HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
          HAL_UART_Receive (&huart1, rxBuffer, 512, 1000);
        if(strstr((char *)rxBuffer,"OK")){
          ATisOK = 1;
        }
        HAL_Delay(500);
      }

      ATisOK = 0;
      while(!ATisOK){
        sprintf(ATcommand,"AT+CWSAP_CUR=\"STM32\",\"cleaningrobot\",1,3,4,0\r\n");
          memset(rxBuffer,0,sizeof(rxBuffer));
          HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
          HAL_UART_Receive (&huart1, rxBuffer, 512, 1000);
        if(strstr((char *)rxBuffer,"OK")){
          ATisOK = 1;
        }
        HAL_Delay(500);
      }

      ATisOK = 0;
      while(!ATisOK){
        sprintf(ATcommand,"AT+CIPAP_CUR=\"192.168.51.1\"\r\n");
        memset(rxBuffer,0,sizeof(rxBuffer));
        HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
        HAL_UART_Receive (&huart1, rxBuffer, 512, 1000);
        if(strstr((char *)rxBuffer,"OK")){
          ATisOK = 1;
        }
        HAL_Delay(500);
      }

      ATisOK = 0;
      while(!ATisOK){
        sprintf(ATcommand,"AT+CIPMUX=1\r\n");
          memset(rxBuffer,0,sizeof(rxBuffer));
          HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
          HAL_UART_Receive (&huart1, rxBuffer, 512, 1000);
          if(strstr((char *)rxBuffer,"OK")){
            ATisOK = 1;
          }
          HAL_Delay(500);
      }

      ATisOK = 0;
      while(!ATisOK){
        sprintf(ATcommand,"AT+CIPSERVER=1,80\r\n");
        memset(rxBuffer,0,sizeof(rxBuffer));
        HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
        HAL_UART_Receive (&huart1, rxBuffer, 512, 1000);
        if(strstr((char *)rxBuffer,"OK")){
            ATisOK = 1;
        }
        HAL_Delay(500);
      }
  HAL_Delay(1000);


  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  char displayBuf[32]; // Buffer for string formatting
  while (1)
  {
	  	  float front = HCSR04_Read(2);
	      HAL_Delay(20);
	      float left  = HCSR04_Read(3);
	      HAL_Delay(20);
	      float right = HCSR04_Read(1);

	      // Xử lý lỗi sensor: Coi lỗi là đường rất thoáng
	      if (front < 0) front = 1000.0f;
	      if (left  < 0) left  = 1000.0f;
	      if (right < 0) right = 1000.0f;

//	      const float TH = 15.0f;


	  //// Test đảo chiều
	  //		GoForward(60);
	  //		HAL_Delay(2000);

	  //		GoBack(60);
	  //		HAL_Delay(2000);

//	  		if(front < TH)
//	  		{
//	  			if( right < TH && left < TH)
//	  			{
//	  				GoBack(60);
//	  				HAL_Delay(600);
//	  				float front = HCSR04_Read(2);
//	  				HAL_Delay(20);
//	  				float left  = HCSR04_Read(3);
//	  				HAL_Delay(20);
//	  				float right = HCSR04_Read(1);
//
//	  				// Xử lý lỗi sensor: Coi lỗi là đường rất thoáng
//	  				if (front < 0) front = 1000.0f;
//	  				if (left  < 0) left  = 1000.0f;
//	  				if (right < 0) right = 1000.0f;
//	  				if(left > TH )
//	  				{
//	  					TurnLeft(60);
//	  					HAL_Delay(600);
//	  				}
//	  				else if (right > TH)
//	  				{
//	  					TurnRight(60);
//	  					HAL_Delay(600);
//	  				}
//	  				else
//	  				{
//	  					GoBack(60);
//	  					HAL_Delay(600);
//	  				}
//	  			}
//	  			else if(right < TH)
//	  			{
//	  				TurnLeft(60);
//	  				HAL_Delay(600);
//	  			}
//	  			else if (left < TH)
//	  			{
//	  				TurnRight(60);
//	  				HAL_Delay(600);
//	  			}
//	  		}
//	  		else
//	  		{
//	  			GoForward(60);
//	  		}


	  memset(rxBuffer,0,sizeof(rxBuffer));
		  HAL_UART_Receive (&huart1, rxBuffer, 512, 1000);
		  if(strstr((char *)rxBuffer,"+IPD,0")) channel = 0;
		  else if(strstr((char *)rxBuffer,"+IPD,1")) channel = 1;
		  else if(strstr((char *)rxBuffer,"+IPD,2")) channel = 2;
		  else if(strstr((char *)rxBuffer,"+IPD,3")) channel = 3;
		  else if(strstr((char *)rxBuffer,"+IPD,4")) channel = 4;
		  else if(strstr((char *)rxBuffer,"+IPD,5")) channel = 5;
		  else if(strstr((char *)rxBuffer,"+IPD,6")) channel = 6;
		  else if(strstr((char *)rxBuffer,"+IPD,7")) channel = 7;
		  else channel = 100;

		  if(strstr((char *)rxBuffer,"GET /wheelon")) wheelState = 0;
		  else if(strstr((char *)rxBuffer,"GET /wheeloff")) wheelState = 1;
		  else if(strstr((char *)rxBuffer,"GET /brushon"))   brushState = 0;
		  else if(strstr((char *)rxBuffer,"GET /brushoff"))  brushState = 1;
		  else {wheelState = wheel;
//		  brushState = brush;
		  }


		  if (brushState) {
		      HAL_GPIO_WritePin(RELAY1_GPIO_Port, RELAY1_Pin, GPIO_PIN_RESET);
		  } else {
		      HAL_GPIO_WritePin(RELAY1_GPIO_Port, RELAY1_Pin, GPIO_PIN_SET);
		  }

		  if(channel<8 && wheelState == 1 )
//				  || brushState == 1)

		  {
//			if(wheelState == 1){
				StopCoast(); wheel = 1;
//			}
//			else if(brushState == 1){HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET); brush = 1;}

			sprintf(ATcommand,"AT+CIPSEND=%d,%d\r\n",channel,countB+countF+countT);
			memset(rxBuffer,0,sizeof(rxBuffer));
			HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
			HAL_UART_Receive (&huart1, rxBuffer, 512, 100);
			if(strstr((char *)rxBuffer,">"))
			{
			  memset(rxBuffer,0,sizeof(rxBuffer));
				HAL_UART_Transmit(&huart1,(uint8_t *)ATcommandB,countB,1000);
				HAL_UART_Transmit(&huart1,(uint8_t *)ATcommandF,countF,1000);
				HAL_UART_Transmit(&huart1,(uint8_t *)ATcommandT,countT,1000);
			   HAL_UART_Receive (&huart1, rxBuffer, 512, 100);
			}
			sprintf(ATcommand,"AT+CIPCLOSE=%d\r\n",channel);
			memset(rxBuffer,0,sizeof(rxBuffer));
			HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
			HAL_UART_Receive (&huart1, rxBuffer, 512, 100);
			channel=100;
		  }
		  else if(channel<8 && wheelState == 0
//				  || brushState == 0)
				  )
		  {
//			if(wheelState == 0){
				GoForward(60); wheel = 0;
//			}
//			else if(brushState == 0){HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET); brush = 0;}

			sprintf(ATcommand,"AT+CIPSEND=%d,%d\r\n",channel,countB+countN+countT);
			memset(rxBuffer,0,sizeof(rxBuffer));
			HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
			HAL_UART_Receive (&huart1, rxBuffer, 512, 100);
			if(strstr((char *)rxBuffer,">"))
			{
			  memset(rxBuffer,0,sizeof(rxBuffer));
				HAL_UART_Transmit(&huart1,(uint8_t *)ATcommandB,countB,1000);
				HAL_UART_Transmit(&huart1,(uint8_t *)ATcommandN,countN,1000);
				HAL_UART_Transmit(&huart1,(uint8_t *)ATcommandT,countT,1000);
				HAL_UART_Receive (&huart1, rxBuffer, 512, 100);
			}
			sprintf(ATcommand,"AT+CIPCLOSE=%d\r\n",channel);
			memset(rxBuffer,0,sizeof(rxBuffer));
			HAL_UART_Transmit(&huart1,(uint8_t *)ATcommand,strlen(ATcommand),1000);
			HAL_UART_Receive (&huart1, rxBuffer, 512, 100);
			channel=100;
		  }


	      // Format the string (e.g., "Dist: 025 cm")
	      // Using %03d ensures the number always has 3 digits, preventing text artifacts
	      sprintf(DistanceBuffer, "Distance: %3f cm", distance_cm);

	      if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_5) == 1)
	      {
//	    	  LedState = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);
	    	  sprintf(MotorBuffer, "Brush State: ON ");
	      }else{
	    	  sprintf(MotorBuffer, "Brush State: OFF");
	      }

//	      sprintf(LedBuffer, "LED State: %3d", LedState);

	      // Draw Text: (Text, Font, X, Y, TextColor, BackgroundColor)
	      ILI9341_DrawText(DistanceBuffer, FONT4, 20, 50, BLACK, WHITE);
	      ILI9341_DrawText(MotorBuffer, FONT4, 20, 170, RED, WHITE);

	      sprintf(displayBuf, "PM 1.0: %u ug/m3  ", sensorData.pm1_0_env);
	      ILI9341_DrawText(displayBuf, FONT3, 20, 80, BLUE, WHITE);

	      sprintf(displayBuf, "PM 2.5: %u ug/m3  ", sensorData.pm2_5_env);
	      ILI9341_DrawText(displayBuf, FONT4, 20, 110, RED, WHITE); // Main value, larger font

	      sprintf(displayBuf, "PM 10.0: %u ug/m3 ", sensorData.pm10_env);
	      ILI9341_DrawText(displayBuf, FONT3, 20, 140, MAGENTA, WHITE);

	      HAL_Delay(1000);

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.ClockSpeed = 100000;
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 0;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 3599;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */
  HAL_TIM_MspPostInit(&htim1);

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_IC_InitTypeDef sConfigIC = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 71;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 65535;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  if (HAL_TIM_IC_ConfigChannel(&htim4, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_ConfigChannel(&htim4, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_ConfigChannel(&htim4, &sConfigIC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 9600;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, IN3_Pin|IN4_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, IN1_Pin|IN2_Pin|CS_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, DC_Pin|RESET_Pin|BUZZER_Pin|TRIG1_Pin
                          |TRIG2_Pin|TRIG3_Pin|RELAY1_Pin|RELAY2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : IN3_Pin IN4_Pin */
  GPIO_InitStruct.Pin = IN3_Pin|IN4_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : IN1_Pin IN2_Pin */
  GPIO_InitStruct.Pin = IN1_Pin|IN2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : CS_Pin */
  GPIO_InitStruct.Pin = CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(CS_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : DC_Pin RESET_Pin BUZZER_Pin RELAY1_Pin
                           RELAY2_Pin */
  GPIO_InitStruct.Pin = DC_Pin|RESET_Pin|BUZZER_Pin|RELAY1_Pin
                          |RELAY2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : TRIG1_Pin TRIG2_Pin TRIG3_Pin */
  GPIO_InitStruct.Pin = TRIG1_Pin|TRIG2_Pin|TRIG3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART2) {
        // Logic to align the 32-byte frame
        if (rxIndex == 0 && rxByte != 0x42) {
            // Wait for first header byte
            rxIndex = 0;
        } else if (rxIndex == 1 && rxByte != 0x4D) {
            // Ensure second header byte matches
            rxIndex = 0;
        } else {
            rxBufferPMS[rxIndex++] = rxByte;
        }

        if (rxIndex == 32) {
            // Checksum verification
            uint16_t checksum = 0;
            for (uint8_t i = 0; i < 30; i++) {
                checksum += rxBufferPMS[i];
            }
            uint16_t receivedChecksum = (rxBufferPMS[30] << 8) | rxBufferPMS[31];

            if (checksum == receivedChecksum) {
                // Mapping Standard (Lab) values
                sensorData.pm1_0_std = (rxBufferPMS[4] << 8) | rxBufferPMS[5];
                sensorData.pm2_5_std = (rxBufferPMS[6] << 8) | rxBufferPMS[7];
                sensorData.pm10_std  = (rxBufferPMS[8] << 8) | rxBufferPMS[9];

                // Mapping Atmospheric (Real World) values
                sensorData.pm1_0_env = (rxBufferPMS[10] << 8) | rxBufferPMS[11];
                sensorData.pm2_5_env = (rxBufferPMS[12] << 8) | rxBufferPMS[13];
                sensorData.pm10_env  = (rxBufferPMS[14] << 8) | rxBufferPMS[15];
            }
            rxIndex = 0; // Reset for next frame
        }

        // Re-enable interrupt for the next byte
        HAL_UART_Receive_IT(&huart2, &rxByte, 1);
    }
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */